---
title: "Crea una API Simple con Go Kit üõ†Ô∏è"
date: "18 de Abril del 2025"
published: "2025-04-18"
abstract: "Go Kit es un excelente toolkit para construir microservicios robustos y mantenibles en Go. Aprende los conceptos b√°sicos creando una API simple paso a paso."
image: "https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Fgo-kit.png?alt=media&token=55421998-d226-4248-923f-e06355c2bfb1"
tag: "Go, GoKit, Microservices"
author: "Carlos Garc√≠a"
---

# Crea una API Simple con Go Kit üõ†Ô∏è

<small>18 de Abril del 2025</small>
<EditPost path="crea-una-api-simple-con-go-kit" />

<img
  width="100%"
  alt="go-kit-microservices"
  src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Fgo-kit.png?alt=media&token=55421998-d226-4248-923f-e06355c2bfb1"
  style={{ borderRadius: "8px" }}
/>

Go Kit es un conjunto de paquetes (un toolkit, no un framework) que ayuda a construir microservicios en Go. No impone una estructura r√≠gida, pero s√≠ promueve patrones que llevan a c√≥digo m√°s estructurado, mantenible y testable, especialmente √∫til a medida que las aplicaciones crecen.

En este post, vamos a explorar los componentes principales de Go Kit creando una API HTTP muy sencilla que devuelva un saludo.

## ¬øPor qu√© usar Go Kit?
Antes de empezar, ¬øpor qu√© elegir Go Kit?
- **Separaci√≥n de Responsabilidades**: Go Kit fomenta dividir la aplicaci√≥n en capas claras: Transporte, Endpoint y Servicio.
- **Componentes Intercambiables**: Facilita cambiar detalles de implementaci√≥n (como pasar de HTTP a gRPC) sin afectar la l√≥gica de negocio.
- **Middleware**: Proporciona un sistema robusto de middleware para a√±adir funcionalidades transversales como logging, m√©tricas, tracing, rate limiting, etc.
- **Infraestructura para Microservicios**: Incluye herramientas para service discovery, circuit breaking y m√°s.

## Las Capas Principales de Go Kit
Una aplicaci√≥n t√≠pica en Go Kit se estructura en tres capas principales:

1.  **Servicio (Service)**: Contiene la l√≥gica de negocio pura. No sabe nada sobre HTTP, JSON, gRPC, etc. Es la capa m√°s interna y testable.
2.  **Endpoint**: Adapta las funciones del servicio a un formato espec√≠fico que Go Kit entiende. Cada m√©todo del servicio suele tener un endpoint correspondiente. Act√∫a como un adaptador.
3.  **Transporte (Transport)**: Expone los endpoints a trav√©s de un medio espec√≠fico como HTTP, gRPC, NATS, etc. Se encarga de decodificar las peticiones entrantes y codificar las respuestas salientes.

Vamos a construir nuestra API "Hola Mundo" siguiendo estas capas.

## 1. Definiendo el Servicio (La L√≥gica de Negocio)
Primero, definimos la interfaz de nuestro servicio y su implementaci√≥n. Queremos un servicio que pueda saludar a un nombre dado.

Crea un archivo `service.go` (por ejemplo, en `pkg/service/service.go`):
<CodeSnippet language="go" code={`package service

import "context"

// Service define la interfaz para nuestro servicio de saludo.
type Service interface {
    Saludar(ctx context.Context, nombre string) (string, error)
}

// Implementaci√≥n simple del servicio.
type simpleService struct{}

// NewService crea una nueva instancia del servicio.
func NewService() Service {
    return simpleService{}
}

// Saludar implementa la l√≥gica de negocio.
func (s simpleService) Saludar(ctx context.Context, nombre string) (string, error) {
    if nombre == "" {
        return "Hola!", nil // Saludo gen√©rico si no hay nombre
    }
    return "Hola, " + nombre + "!", nil
}
`}/>

## 2. Creando el Endpoint
El endpoint envuelve nuestro m√©todo `Saludar` del servicio. Necesitamos definir las estructuras de petici√≥n y respuesta para este endpoint.

Crea un archivo `endpoint.go` (por ejemplo, en `pkg/endpoint/endpoint.go`):
<CodeSnippet language="go" code={`package endpoint

import (
    "context"
    "github.com/go-kit/kit/endpoint"
    "your_module_path/pkg/service" // Reemplaza con tu ruta de m√≥dulo
)

// SaludarRequest define la estructura de la petici√≥n para el endpoint Saludar.
type SaludarRequest struct {
    Nombre string json:"nombre"
}

// SaludarResponse define la estructura de la respuesta para el endpoint Saludar.
type SaludarResponse struct {
    Saludo string json:"saludo"
    Err    string json:"err,omitempty" // Los errores no se devuelven directamente en JSON usualmente
}

// MakeSaludarEndpoint crea un endpoint para el m√©todo Saludar del servicio.
func MakeSaludarEndpoint(svc service.Service) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(SaludarRequest) // Type assertion
        saludo, err := svc.Saludar(ctx, req.Nombre)
        if err != nil {
            // En una app real, manejar√≠as el error de forma m√°s robusta
            return SaludarResponse{Saludo: saludo, Err: err.Error()}, nil
        }
        return SaludarResponse{Saludo: saludo, Err: ""}, nil
    }
}
`}/>
*Nota: Aseg√∫rate de reemplazar `your_module_path` con la ruta correcta de tu m√≥dulo Go.*

## 3. Configurando el Transporte HTTP
Ahora, exponemos nuestro endpoint a trav√©s de HTTP. Necesitamos funciones para decodificar la petici√≥n HTTP entrante a nuestra `SaludarRequest` y codificar la `SaludarResponse` a una respuesta HTTP.

Crea un archivo `transport_http.go` (por ejemplo, en `pkg/transport/http.go`):
<CodeSnippet language="go" code={`package transport

import (
    "context"
    "encoding/json"
    "net/http"

    "github.com/go-kit/kit/endpoint"
    httptransport "github.com/go-kit/kit/transport/http"
    "your_module_path/pkg/endpoint" // Reemplaza con tu ruta de m√≥dulo
)

// NewHTTPHandler crea un manejador HTTP para los endpoints del servicio.
func NewHTTPHandler(ep endpoint.Endpoint) http.Handler {
    mux := http.NewServeMux()
    mux.Handle("/saludar", httptransport.NewServer(
        ep,
        decodeSaludarRequest,
        encodeResponse,
    ))
    // Puedes a√±adir m√°s rutas aqu√≠ para otros endpoints
    return mux
}

// decodeSaludarRequest decodifica la petici√≥n HTTP a SaludarRequest.
func decodeSaludarRequest(_ context.Context, r *http.Request) (interface{}, error) {
    var request endpoint.SaludarRequest
    // Intentamos decodificar el nombre desde query param o JSON body
    if name := r.URL.Query().Get("nombre"); name != "" {
         request.Nombre = name
    } else if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
        // Si no hay nombre en query y falla el decode del body (o est√° vac√≠o)
        // Devolvemos un request con nombre vac√≠o para el saludo gen√©rico.
        // En una API real, podr√≠as devolver un error BadRequest aqu√≠.
        request.Nombre = ""
    }
    return request, nil
}

// encodeResponse codifica la respuesta del endpoint a formato JSON para HTTP.
func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
    w.Header().Set("Content-Type", "application/json; charset=utf-8")
    // Aqu√≠ puedes manejar c√≥digos de status basados en la respuesta si es necesario
    // Por ejemplo, si response contiene un error.
    // if e, ok := response.(endpoint.Failer); ok && e.Failed() != nil {
    //     encodeErrorResponse(ctx, e.Failed(), w) // Funci√≥n separada para errores
    //     return nil
    // }
    return json.NewEncoder(w).Encode(response)
}
`}/>

## 4. Uniendo Todo en `main.go`
Finalmente, en nuestro `main.go` (por ejemplo, en `cmd/server/main.go`), instanciamos todas las capas y arrancamos el servidor HTTP.

<CodeSnippet language="go" code={`package main

import (
    "log"
    "net/http"

    "your_module_path/pkg/service"    // Reemplaza con tu ruta de m√≥dulo
    "your_module_path/pkg/endpoint"   // Reemplaza con tu ruta de m√≥dulo
    "your_module_path/pkg/transport"  // Reemplaza con tu ruta de m√≥dulo
)

func main() {
    // 1. Crear el servicio
    svc := service.NewService()

    // 2. Crear el endpoint
    saludarEndpoint := endpoint.MakeSaludarEndpoint(svc)

    // 3. Crear el manejador HTTP
    httpHandler := transport.NewHTTPHandler(saludarEndpoint)

    // 4. Iniciar el servidor HTTP
    port := ":8080"
    log.Printf("Servidor escuchando en puerto %s", port)
    log.Fatal(http.ListenAndServe(port, httpHandler))
}
`}/>

## Estructura de Carpetas Sugerida
Una posible estructura para este proyecto podr√≠a ser:

<FolderStructure
  repo="https://github.com/your-username/go-kit-saludo-api"
  tree={[
    {
      type: "folder",
      name: "cmd",
      content: [
        {
          type: "folder",
          name: "saludo-api",
          content: [
            { type: "file", name: "main.go", extension: "go" }
          ]
        }
      ]
    },
    {
      type: "folder",
      name: "internal",
      content: [
        {
          type: "folder",
          name: "config",
          content: [
            { type: "file", name: "config.go", extension: "go" }
          ]
        },
        {
          type: "folder",
          name: "service",
          content: [
            { type: "file", name: "service.go", extension: "go" },
            { type: "file", name: "instrumentation.go", extension: "go" }
          ]
        },
        {
          type: "folder",
          name: "endpoint",
          content: [
            { type: "file", name: "set.go", extension: "go" },
            { type: "file", name: "request_response.go", extension: "go" },
            { type: "file", name: "middleware.go", extension: "go" }
          ]
        },
        {
          type: "folder",
          name: "transport",
          content: [
            {
              type: "folder",
              name: "http",
              content: [
                { type: "file", name: "handler.go", extension: "go" },
                { type: "file", name: "encode_decode.go", extension: "go" }
              ]
            }
          ]
        }
      ]
    },
    { type: "file", name: "go.mod" },
    { type: "file", name: "go.sum" },
    { type: "file", name: "Makefile" },
    { type: "file", name: "Dockerfile" }
  ]}
/>


## Probando la API
1.  Inicializa tu m√≥dulo Go: `go mod init your_module_path`
2.  Descarga las dependencias: `go mod tidy`
3.  Ejecuta el servidor: `go run ./cmd/server/main.go`
4.  Abre tu navegador o usa `curl`:
    * `curl http://localhost:8080/saludar` (Devolver√° `{"saludo":"Hola!"}`)
    * `curl http://localhost:8080/saludar?nombre=Carlos` (Devolver√° `{"saludo":"Hola, Carlos!"}`)
    * `curl -X POST -H "Content-Type: application/json" -d '{"nombre":"Mundo"}' http://localhost:8080/saludar` (Devolver√° `{"saludo":"Hola, Mundo!"}`)

## Conclusi√≥n
Hemos creado una API HTTP muy simple utilizando Go Kit, separando claramente la l√≥gica de negocio (servicio), la adaptaci√≥n (endpoint) y la comunicaci√≥n (transporte). Esta estructura, aunque parece verbosa para un ejemplo tan peque√±o, escala muy bien para aplicaciones m√°s complejas y facilita la adici√≥n de funcionalidades como logging, m√©tricas o diferentes transportes (como gRPC) de forma organizada.

Go Kit ofrece mucho m√°s, te animo a explorar su <BlogLink url="https://gokit.io/examples/" content="documentaci√≥n y ejemplos oficiales"/> para aprender sobre middleware, gRPC, service discovery y otras caracter√≠sticas avanzadas.
