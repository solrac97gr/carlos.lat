---
title: "Â¿CÃ³mo mapear un Array de Structs a un Array de Interfaces en Go ğŸ¹?"
date: "05 de Noviembre del 2021"
published: "2021-11-05"
abstract: " âœ… Lo que sucede cuando tiene un mÃ©todo para insertar varios documentos en MongoDB pero es la misma acciÃ³n para diferentes tipos de datos. "
image: "https://miro.medium.com/max/1400/1*IHqSJ2_7CeaU675YRdLY2g.jpeg"
tag: "Go"
author: "Carlos GarcÃ­a"
---

# Â¿CÃ³mo mapear un Array de Structs a un Array de Interfaces en Go ğŸ¹?

<small>05 de Noviembre del 2021</small><EditPost path="como-mapear-array-structs-interface" />

<img
  width="100%"
  src="https://miro.medium.com/max/1400/1*IHqSJ2_7CeaU675YRdLY2g.jpeg"
  alt="golang wallpaper"
  style={{borderRadius:"8px"}}
></img>

```go
      fmt.Println("Hello World ğŸŒ")
```

En mi tiempo de programaciÃ³n con go, un problema recurrente es tratar de hacer que los mÃ©todos puedan funcionar con diferentes parÃ¡metros de tipos de datos, por ejemplo, lo que sucede cuando tiene un mÃ©todo para insertar varios documentos en MongoDB pero es la misma acciÃ³n para diferentes tipos de datos. La forma lÃ³gica de resolver este problema es usar una Array de interfaz como en el siguiente ejemplo.

<CodeSnippet language="go" code={
`func SaveToMongo(documents []interface{}, collectionName string) {
    ctx, cancelFunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelFunc()

    client, err := mongo.Connect(ctx, options.Client().ApplyURI(
        MongoCon,
    ))
    if err != nil {
            println(err.Error())
    }

    collection := client.Database("test").Collection(collectionName)
    _, err = collection.InsertMany(ctx, documents)
    if err != nil {
        println(err.Error())
    }
}`
} />

Pero cuando intenta enviar datos a este mÃ©todo, por ejemplo, una array de struct, obtiene un error de tipos incompatibles.

### Entonces Â¿CuÃ¡l es la soluciÃ³n...?

Para hacer que este mÃ©todo funcione y el mÃ©todo InsertMany tambiÃ©n, en mi caso, tengo diferentes mÃ©todos que me devuelven una matriz de diferentes tipos de estructuras en el mismo mÃ©todo. Devuelvo esa matriz. Asigno la matriz a una []interfaz.

<CodeSnippet language="go" code={`
    func GetComments() (logResultsInt []interface{}) {
        var logResults []models.Comments
        ...
        for _, log := range logResults {
            logResultsInt = append(logResultsInt, log)
        }
        return logResultsInt
    }
`} />

### ConclusiÃ³n

Con Go podemos resolver problemas y casos en los que necesitamos usar un "tipo dinÃ¡mico", incluso si es un lenguaje de tipado estÃ¡tico. Espero ayudar a alguien con este formato corto resolviendo pequeÃ±os problemas que tengo en mi dÃ­a de trabajo.

### EdiciÃ³n

Gracias a <BlogLink url="https://yael-castro.medium.com" content="Yael Castro"/> por esta sugerencia de una funciÃ³n que realiza la conversiÃ³n de manera mÃ¡s eficiente.

<CodeSnippet language="go" code={`
    package main

    import "fmt"

    type Empty struct{}

    func toInterfaceSlice(slice ...interface{}) []interface{} {
        return slice
    }

    func main() {
        slice := []Empty{}

        arr := toInterfaceSlice(slice)

        fmt.Printf("%T", arr)
    }
`} />

