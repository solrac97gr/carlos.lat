---
title: "Mejora tu DX en Go con Makefiles üêπ"
date: "15 de Junio del 2023"
published: "2023-06-15"
abstract: "Mejora tu flujo de desarrollo usando archivos Makefile y scripts para tus proyectos en Go."
image: "https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Fgo-minimal.jpeg?alt=media&token=2af7f91a-5e96-460d-82b4-22ad94448705"
tag: "Go, DX, Bash"
author: "Carlos Garc√≠a"
---

# Mejora tu DX en Go con Makefiles üêπ 

<small>15 de Junio del 2023</small>
<EditPost path="mejora-desarrollo-go-makefile" />

<img
  width="100%"
  alt="golang-wallpaper "
  src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Fgo-minimal.jpeg?alt=media&token=2af7f91a-5e96-460d-82b4-22ad94448705"
  style={{ borderRadius: "8px" }}
/>

Algo muy importante como desarrolladores es disfrutar de nuestro trabajo y de ayudar a que todo el equipo tambi√©n disfrute de este. Por eso existe el t√©rmino DX (Developer Experience) y en este Post nos adentraremos en una forma sencilla de mejorar la DX de nuestros proyectos en Go usando los ya conocidos Makefiles (creados en los 70‚Äôs ü§Ø).

## ¬øQu√© es un Makefile?

Un Makefile es una herramienta para simplificar u organizar el c√≥digo para la compilaci√≥n. Un Makefile es un conjunto de comandos con nombres de variables y metas para crear o eliminar archivos objetos y binarios. Un Makefile se puede usar para compilar c√≥digo en lenguajes como C o C++, o para proporcionar comandos para automatizar tareas comunes. Un Makefile ayuda a decidir qu√© partes de un programa grande deben recompilarse.

## ¬øC√≥mo un Makefile mejorar√° nuestra DX en Go?

Si has tenido la oportunidad de trabajar en el lado del Frontend, sabr√°s que existe dentro del Package.json una lista de comandos que puedes personalizar para realizar tareas espec√≠ficas, como ejecutar los Tests, aplicar un Linter, construir la aplicaci√≥n o ejecutarla. Pues bien, eso har√° nuestro Makefile por nosotros en Go.

Nuestro Makefile en Go nos ayudar√° a organizar nuestros distintos comandos, haciendo que no tengamos que ense√±arles espec√≠ficamente a cada nuevo developer en el proyecto largos comandos para generar mocks, por ejemplo, o para obtener un formato espec√≠fico de code coverage.

## Ejemplos de comandos que se pueden agregar a nuestro Makefile

Primero partiremos de la base de que en nuestro proyecto de Go contamos con una carpeta scripts. Una vez claro esto, crearemos un archivo Makefile en la ra√≠z de este y ah√≠ agregaremos nuestros distintos comandos que usaremos.

Nuestro proyecto se ver√≠a algo as√≠ (Dejar√© los folders vac√≠os para no distraernos. Este template es de mi Post <BlogLink url="/blog/plantilla-proyecto-2023/" content="Plantilla de proyecto 2023"/>).


<FolderStructure
  tree={[
    {   
        type:"folder",
        name:".github",
        content:[
            
        ]
    },
    {
      type: "folder",
      name: "cmd",
      content: [
      ],
    },
    {
        type:"folder",
        name:"config",
        content:[
           
        ]
    },
    {
        type:"folder",
        name:"deploy",
        content:[
            
        ]
    },
    {
        type:"folder",
        name:"docs",
        content:[
          
        ]
    },
    {
        type:"folder",
        name:"hooks",
        content:[
          
        ]
    },
    {
      type: "folder",
      name: "internal",
      content: [
       
      ],
    },
    {
        type:"folder",
        name:"logs",
        content:[
         
        ]
    },
    {
        type:"folder",
        name:"pkg",
        content:[
          
        ]
    },
    {
        type:"folder",
        name:"scripts",
        content:[
            {
                type:"file",
                name:"build.sh",
            },
            {
                type:"file",
                name:"generate-mocks.sh"
            }
        ]
    },
    {
        type:"file",
        name:".gitignore"
    },
    {
      type: "file",
      name: "go.mod",
    },
    {
      type: "file",
      name: "go.sum",
    },
    {
        type:"file",
        name:"main.go"
    },
    {
        type:"file",
        name:"README.md"
    },
    {
        type:"file",
        name:"Makefile"
    }
  ]}
/>

Nuestro makefile quedar√≠a de la siguiente forma: definir√≠amos los distintos scripts que queremos usar con la palabra clave make. En este caso, haremos el proceso de Build, Test, Run y Generaci√≥n de Mocks.

### 1. Definimos nuestros comandos a usar.

Primero definimos las herramientas que usaremos en variables que nos recuerden las acciones que realizamos normalmente con el CLI de go. Esto lo hacemos para que, si nuestro makefile crece y luego alguna de las herramientas de go cambia de nombre, podamos reemplazarla f√°cilmente sin modificar cada comando de forma unitaria.

<CodeSnippet  language={"Makefile"} code={`
# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOTOOL=$(GOCMD) tool
GOGET=$(GOCMD) get
GOMOD=$(GOCMD) mod
GOINST=$(GOCMD) install
`} />

### 2. Definimos nuestro comando de Build

Un proceso com√∫n en Go es crear nuestra aplicaci√≥n y, al llegar nuevos desarrolladores, recordar los par√°metros de construcci√≥n puede ser un poco tedioso. Entonces, nos ayudaremos del Makefile para definir nuestro comando de construcci√≥n del proyecto.

<CodeSnippet  language={"Makefile"} code={`
# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOTOOL=$(GOCMD) tool
GOGET=$(GOCMD) get
GOMOD=$(GOCMD) mod
GOINST=$(GOCMD) install

#Binary Name
BINARY_NAME=main

# Build
build:
    @$(GOBUILD) -o $(BINARY_NAME) ./cmd/http
    @echo "üì¶ Build Done"
`} />

### 3. Agregamos nuestro comando de Tests

Otro proceso com√∫n en Go es ejecutar los tests de nuestra aplicaci√≥n para verificar su correcto funcionamiento y detectar posibles errores. Para ello, podemos usar el comando go test, que busca y ejecuta los archivos que terminan en _test.go en nuestro proyecto. Sin embargo, este comando puede tener varias opciones y argumentos que pueden complicar su uso. Por ejemplo, podemos querer especificar el nivel de cobertura de los tests, el formato de salida, los paquetes a testear o los flags a pasar al test runner. Para simplificar este proceso, podemos definir nuestro comando de tests en el Makefile, usando las variables que definimos anteriormente y agregando las opciones que necesitemos.

<CodeSnippet  language={"Makefile"} code={`
# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOTOOL=$(GOCMD) tool
GOGET=$(GOCMD) get
GOMOD=$(GOCMD) mod
GOINST=$(GOCMD) install

#Binary Name
BINARY_NAME=main

# Build
build:
    @$(GOBUILD) -o $(BINARY_NAME) ./cmd/http
    @echo "üì¶ Build Done"

# Test
test:
	@$(GOTEST) -v ./...
	@echo "üß™ Test Completed"
`} />

### 4. Agregamos ahora nuestro comando de Ejecuci√≥n de nuestro binario.

Una vez que hemos construido nuestro binario con el comando make build, podemos ejecutarlo directamente desde la terminal con ./main. Sin embargo, puede ser conveniente definir un comando en el Makefile para ejecutar nuestro binario de forma m√°s sencilla y consistente. Para ello, podemos usar el comando run y especificar el nombre del binario que queremos ejecutar. As√≠, podremos iniciar nuestra aplicaci√≥n con solo escribir make run en la terminal.

<CodeSnippet  language={"Makefile"} code={`
# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOTOOL=$(GOCMD) tool
GOGET=$(GOCMD) get
GOMOD=$(GOCMD) mod
GOINST=$(GOCMD) install

#Binary Name
BINARY_NAME=main

# Build
build:
    @$(GOBUILD) -o $(BINARY_NAME) ./cmd/http
    @echo "üì¶ Build Done"

# Test
test:
	@$(GOTEST) -v ./...
	@echo "üß™ Test Completed"

# Run
run:
    @echo "üöÄ Running App"
    @./$(BINARY_NAME)
`} />

### 5. Tambien podemos ejecutar scripts m√°s complejos usando la carpeta de scripts.

A veces, podemos necesitar ejecutar scripts que realizan tareas m√°s complejas que las que podemos definir en el Makefile. Por ejemplo, podemos querer generar mocks para nuestros tests, formatear nuestro c√≥digo o generar documentaci√≥n. Para ello, podemos usar la carpeta de scripts que hemos creado en nuestro proyecto y almacenar ah√≠ los scripts que queremos ejecutar. Luego, podemos definir comandos en el Makefile que invocan esos scripts usando el comando sh. As√≠, podremos ejecutar nuestros scripts con solo escribir make script-name en la terminal

<CodeSnippet  language={"Makefile"} code={`
# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOTOOL=$(GOCMD) tool
GOGET=$(GOCMD) get
GOMOD=$(GOCMD) mod
GOINST=$(GOCMD) install

#Binary Name
BINARY_NAME=main

# Build
build:
    @$(GOBUILD) -o $(BINARY_NAME) ./cmd/http
    @echo "üì¶ Build Done"

# Test
test:
	@$(GOTEST) -v ./...
	@echo "üß™ Test Completed"

# Run
run:
    @echo "üöÄ Running App"
    @./$(BINARY_NAME)

# Generate Mocks
generate-mocks:
	@$(GOINST) github.com/golang/mock/mockgen@v1.6.0

	@./scripts/generate-mocks.sh
`} />

### 6. Tambien podemos llamar otros comandos de nuestro make file

Digamos que queremos tener un comando dev que nos construya y ejecute la app al mismo tiempo. Para ello, crearemos nuestro comando dev con la dependencia del comando build. Esto significa que, antes de ejecutar el comando dev, se ejecutar√° el comando build para asegurarnos de que tenemos el binario actualizado. Luego, el comando dev ejecutar√° el binario usando el nombre que le hemos asignado. As√≠, podremos iniciar nuestra app con solo escribir make dev en la terminal.

<CodeSnippet  language={"Makefile"} code={`
# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOTOOL=$(GOCMD) tool
GOGET=$(GOCMD) get
GOMOD=$(GOCMD) mod
GOINST=$(GOCMD) install

#Binary Name
BINARY_NAME=main

# Build
build:
    @$(GOBUILD) -o $(BINARY_NAME) ./cmd/http
    @echo "üì¶ Build Done"

# Test
test:
	@$(GOTEST) -v ./...
	@echo "üß™ Test Completed"

# Run
run:
    @echo "üöÄ Running App"
    @./$(BINARY_NAME)

# Generate Mocks
generate-mocks:
	@$(GOINST) github.com/golang/mock/mockgen@v1.6.0

	@./scripts/generate-mocks.sh

# Dev
dev:build
    @echo "üöÄ Running App"
    @./$(BINARY_NAME)
`} />



## Usando nuestros comandos



Para usar nuestros comandos del Makefile es muy simple: usaremos la palabra clave make seguida del nombre del comando que queremos realizar.

#### Veremos aqu√≠ unos ejemplos de c√≥mo usarlo:

- Para construir nuestra aplicaci√≥n usaremos el comando `make build`

    <CodeSnippet language={"bash"} code={`make build`} output={"üì¶ Build Done"}/>

- Para ejecutar nuestros tests usaremos el comando `make test`

    <CodeSnippet language={"bash"} code={`make test`} output={"üß™ Test Completed"}/>

- Para ejecutar nuestros programa en modo dev `make dev`

    <CodeSnippet language={"bash"} code={`make dev`} output={"üöÄ Running App"}/>

## Conclusi√≥n

En este art√≠culo hemos visto c√≥mo los Makefiles pueden mejorar nuestra experiencia de desarrollo en Go, al simplificar y organizar los comandos que usamos para construir, ejecutar y testear nuestra aplicaci√≥n. Hemos aprendido la sintaxis b√°sica de un Makefile, c√≥mo definir variables, objetivos y dependencias, y c√≥mo ejecutar scripts m√°s complejos desde el Makefile. Tambi√©n hemos visto algunos ejemplos de comandos √∫tiles que podemos usar en nuestros proyectos de Go, como build, test, run y dev. Espero que este art√≠culo te haya sido de utilidad y que te animes a usar los Makefiles en tus proyectos de Go. ¬°Hasta la pr√≥xima!