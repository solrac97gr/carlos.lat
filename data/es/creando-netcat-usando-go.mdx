---
title: "Creando NetCat usando Go 游닌"
date: "26 de Julio del 2022"
published: "2022-07-26"
abstract: "Para este blog construiremos una soluci칩n en Go que nos permita obtener el comportamiento de una clase en otros lenguajes de programaci칩n."
image: "https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Ff36611152c8c09bfff77656fb0653249.jpeg?alt=media&token=722321a3-6cd6-40ec-a2bd-01cd67b081d1"
tag: "Go"
author: "Carlos Garc칤a"
---

# Creando NetCat usando Go 游닌

<small>26 de Julio del 2022</small>

<img
  width="100%"
  alt="cat-programmer-wallpaper"
  src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Ff36611152c8c09bfff77656fb0653249.jpeg?alt=media&token=722321a3-6cd6-40ec-a2bd-01cd67b081d1"
  style={{borderRadius:"8px"}}
/>

En este art칤culo crearemos un cliente Netcat que nos servir치 como interfaz en la terminal para un servidor de chat que estaremos implementando usando Go y el paquete Standar de Net

Para ello debemos entender que nos estaremos conectando usando el protocolo TCP y aprenderemos a usar Flags para poder enviar informaci칩n a nuestro runtime de Go mediante par치metros en la terminal.

## 쯈u칠 es el protocolo TCP y para que sirve ?

TCP es el Protocolo de Control de Transmisi칩n que permite establecer una conexi칩n y el intercambio de datos entre dos anfitriones. Este protocolo proporciona un transporte fiable de datos.

[Aprende m치s sobre TCP](https://openwebinars.net/blog/que-es-tcpip/)

## 쯈u칠 es una flag en Go?

Un Flag es una entidad dentro del paquete flags que son extra칤das de la ejecuci칩n del programa y que nos ayuda a hacer un programa de l칤nea de comandos parametrizable.

Se ven de la siguiente forma en un programa ya compilado.

<CodeSnippet language="bash" code={`./main --environment="dev"`} />

Y as칤 en un programa que no a sido construido a칰n.

<CodeSnippet language="bash" code={`go run main.go --environment="dev"`} />

En el c칩digo de nuestro programa se usan de la siguiente forma.

<CodeSnippet language="go" code={`package main

import "flag"

var env *string

func init() {
  env = flag.String("env","production","our execution environment ")
}

func main() {
  flag.Parse()

  println(*env)
}`} />


## Manos a la obra con nuestro paquete de Netcat

Nuestra estrategia consistir치 en lo siguiente obtener por flags los par치metros del host y port en primer lugar.

<CodeSnippet language="go" code={`package main

import (
	"flag"
)

var (
	host *string
	port *int
)

func init() {
	host = flag.String("h", "localhost", "hostname")
	port = flag.Int("p", 3090, "port")
}

func main() {
	flag.Parse()
}`} />

Luego definir un m칠todo que copiar치 el contenido de nuestra comunicaci칩n.

<CodeSnippet language="go" code={`func CopyContent(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}`} />

Y ahora en la funci칩n main nos conectaremos al servidor de TCP y enviaremos y obtendremos informaci칩n.

<CodeSnippet language="go" code={`package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
)

var (
	host *string
	port *int
)

func init() {
	host = flag.String("h", "localhost", "hostname")
	port = flag.Int("p", 3090, "port")
}

func main() {
	flag.Parse()
	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", *host, *port))
	if err != nil {
		log.Fatal(err)
	}
	log.Print("Connected")
	done := make(chan struct{})

	go func() {
		io.Copy(os.Stdout, conn)
		done <- struct{}{}
	}()

	CopyContent(conn, os.Stdin)
	conn.Close()
	<-done
}

func CopyContent(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}`} />


Con este simple programa podremos conectador a un servidor TCP y esperar nuevos mensajes para imprimir el contenido en pantalla, a su vez enviar contenido por consola hacia el servidor de TCP.
