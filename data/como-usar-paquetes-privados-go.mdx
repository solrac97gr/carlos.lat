---
title: "Proyectos modulares en Go usando paquetes privados "
date: "22 de Junio del 2023"
published: "2023-06-22"
abstract: "Aprende c贸mo simplificar tus proyectos en Go con paquetes privados y dise帽o modular ."
image: "https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Fgo-private-packages.png?alt=media&token=e5d3d24c-506c-41f2-be1c-1e3b0e0b9df0"
tag: "Go, Modules, Private"
author: "Carlos Garc铆a"
---

# Proyectos modulares en Go usando paquetes privados  

<small>22 de Junio del 2023</small>
<EditPost path="como-usar-paquetes-privados-go" />

<img
  width="100%"
  alt="golang-wallpaper "
  src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Fgo-private-packages.png?alt=media&token=e5d3d24c-506c-41f2-be1c-1e3b0e0b9df0"
  style={{ borderRadius: "8px" }}
/>

Mientras desarrollo, me he estado encontrando con problemas cada vez m谩s recurrentes, y uno de ellos es la reutilizaci贸n de m贸dulos entre proyectos. Esto es algo que se puede aprovechar muy bien en Go, ya que es un lenguaje dise帽ado para trabajar de manera modular.

## 驴Qu茅 es un paquete en Go?

En Go, un paquete es una forma de organizar y reutilizar c贸digo. Un paquete puede contener uno o m谩s archivos fuente de Go y puede ser importado en otros programas de Go para usar sus funciones, variables y tipos exportados. Es un concepto fundamental en la programaci贸n de Go y ayuda a crear c贸digo modular y reutilizable.

## Ventajas de usar paquetes privados

 1. Mayor seguridad: Los paquetes privados nos permiten proteger nuestro c贸digo fuente y evitar que sea accedido por personas no autorizadas.
 2. Mayor control: Al tener paquetes privados, podemos tener un mayor control sobre las dependencias de nuestro proyecto y asegurarnos de que se est茅n utilizando las versiones correctas.
 3. Mejora la reutilizaci贸n de c贸digo: Los paquetes privados nos permiten compartir c贸digo entre proyectos de nuestra empresa de manera m谩s eficiente, lo que puede mejorar la productividad y reducir el tiempo de desarrollo.
 4. Mayor escalabilidad: Con paquetes privados, podemos construir proyectos m谩s grandes y complejos con mayor facilidad, ya que nos permite dividir nuestro c贸digo en m贸dulos m谩s peque帽os y manejables.
 5. Mejora la calidad del c贸digo: Al tener paquetes privados, podemos asegurarnos de que nuestro c贸digo est茅 bien estructurado y siga las mejores pr谩cticas de programaci贸n, lo que puede mejorar la calidad del c贸digo y reducir la cantidad de errores.

 <PromoBanner/>

## 驴C贸mo creamos un paquete privado en Go?

Para esto, plantearemos la siguiente situaci贸n:

> Trabajamos en un equipo de m谩s de 20 desarrolladores y nuestros proyectos necesitan una forma m谩s homog茅nea de manejar los Logs, pero la naturaleza de nuestros proyectos nos obliga a ofuscar informaci贸n sensible en nuestros Logs.

Este es un caso perfecto para aplicar el uso de paquetes privados. Podr铆amos proceder de la siguiente forma:

1. Asignamos el proyecto del registro a un desarrollador espec铆fico (el que tenga m谩s experiencia en el tema).
2. El equipo de desarrolladores llega a un acuerdo para modelar la interfaz del Logger.
3. Comienza la fase de desarrollo de nuestro proyecto de Logging.
    **Ahora pondremos un ejemplo de c贸mo podr铆a verse nuestro paquete de Go.**

    <FolderStructure
    repo="https://github.com/solrac97gr/private-packages-go"
    tree={[
        {
            type:"folder",
            name:"internal",
            content:[
                {
                    type:"folder",
                    name:"obfuscator",
                    content:[
                        {
                            type:"file",
                            name:"obfuscator.go",
                        },
                    ]
                },
            ]
        },
        {
            type:"folder",
            name:"logger",
            content:[
                {
                    type:"file",
                    name:"logger.go",
                },
            ]
        },
        {
            type:"file",
            name:".gitignore"
        },
        {
        type: "file",
        name: "go.mod",
        },
        {
        type: "file",
        name: "go.sum",
        },
        {
            type:"file",
            name:"README.md"
        },
    ]}
    />

    Como pueden apreciar, nuestro paquete cuenta con dos subpaquetes: uno llamado Logger en la ra铆z del proyecto y otro llamado Obfuscator dentro de la carpeta Internal.

    > Tip : Todo el c贸digo dentro de la carpeta  internal  hace que sea imposible de importar. De esta manera, podemos mantener funcionalidades ocultas para la exportaci贸n en otros proyectos donde se usar谩 el paquete.

5. Ahora desarrollamos nuestros dos paquetes (lo har茅 lo m谩s breve y simple posible ya que el enfoque de este art铆culo no es ense帽arles a hacer un logger)

    <CodeSnippet  language={"go"} code={`package logger

    import (
        "fmt"

        "private-packages-go/internal/obfuscator"
    )

    type Logger interface {
        Debug(msg string)
    }

    type CompanyLogger struct {
        obfuscator *obfuscator.Obfuscator
    }

    func NewCompanyLogger() *CompanyLogger {
        o := obfuscator.NewObfuscator()

        return &CompanyLogger{
            obfuscator: o,
        }
    }

    func (c *CompanyLogger) Debug(msg string) {
        nMsg := c.obfuscator.Obfuscate(msg)
        fmt.Println(nMsg)
    }`} />

    Si pueden notar algo, es que el ofuscador se inicializa y asigna dentro del "constructor" del logger, y no se puede asignar desde el "constructor". Esto permite que nadie pueda cambiar la l贸gica de qu茅 cosa se oculta o no. 
 
    Si tu paquete necesita alguna otra parte de tu proyecto, como un ofuscador personalizado, lo ideal es pasar una interfaz en el constructor que los ofuscadores deban cumplir, en lugar de una implementaci贸n. 
    
    En nuestro caso, el ofuscador ser谩 煤nico y controlado por el paquete de Logging.

6. Es hora de cargar nuestro paquete en un repositorio privado en GitHub y comenzar a usarlo en otros proyectos.


## 驴C贸mo usamos paquetes privados en Go?

> Para esto necesitamos tener configurado nuestra <BlogLink url="/blog/como-obtener-variables-entorno-go-env-json/" content="SSH Key de Github en nuestra computadora"/>.

1. Cambiar茅mos el URL de Git usando el siguiente comando:
    <CodeSnippet  language={"bash"} code={`git config --global url.git@github.com:.insteadOf https://github.com/`} />
2. Para estar seguros revisar茅mos si la configuraci贸n se cambio de forma correcta.
    <CodeSnippet  language={"bash"} code={`cat ~/.gitconfig`} output={`[url "git@github.com:"]
    insteadOf = https://github.com/`}/>
3. Agregamos el m贸dulo en la variable GOPRIVATE.
    <CodeSnippet  language={"bash"} code={`export GOPRIVATE=github.com/private/repo`}/>
4. Ahora simplemente usamos la herramienta `get` de Go para traer el paquete a nuestro proyecto.
    <CodeSnippet  language={"bash"} code={`go get github.com/private/repo`}/>
5. Momento de usar nuestro paquete de Go.
    <CodeSnippet  language={"go"} code={`package main

    import "github.com/solrac97gr/private-packages-go/logger"

    type Service struct {
        logger logger.Logger
    }

    func NewService(l logger.Logger) *Service {
        return &Service{
            logger: l,
        }
    }

    func (s *Service) DoSomething() {
        msg := "I am secret か, I am not a secret "
        s.logger.Debug(msg)
    }

    func main() {
        lggr := logger.NewCompanyLogger()
        srv := NewService(lggr)
        srv.DoSomething()
    }
    `} output={`I am not a secret `} />

    Podemos notar que estamos usando la interfaz y no la implementaci贸n, lo que nos permitir谩 usar mocks en el futuro para mejorar las pruebas. Adem谩s, debemos considerar que los paquetes deben tener sus propias pruebas, lo cual no es opcional.

## Conclusi贸n

En conclusi贸n, la reutilizaci贸n de m贸dulos entre proyectos es un problema com煤n en el desarrollo de software, pero en Go, este problema puede ser abordado de manera efectiva gracias a su dise帽o modular. Al aprovechar los paquetes privados, podemos compartir c贸digo de manera m谩s eficiente y mejorar la reutilizaci贸n de m贸dulos entre proyectos. De esta manera, podemos mejorar la productividad y reducir el tiempo de desarrollo en nuestra empresa.