---
title: "Arquitectura Hexagonal usando Go (Fiber)ğŸ‘¨ğŸ½â€ğŸ’»"
date: "15-11-2021"
abstract: "Si realmente quieres mejorar en el tiempo de desarrollo y especialmente en el tiempo de integraciÃ³n de nuevas tecnologÃ­as en tu proyecto definitivamente la Arquitectura Hexagonal es la mejor decision."
image: "https://miro.medium.com/max/1400/1*xofqkz49chC9XliDAuH1Qw.png"
tag: "go"
---

# Arquitectura Hexagonal usando Go (Fiber)ğŸ‘¨ğŸ½â€ğŸ’»

<small>01/06/2022</small>

Si realmente quieres mejorar en el tiempo de desarrollo y especialmente en el tiempo de integraciÃ³n de nuevas tecnologÃ­as en tu proyecto definitivamente la Arquitectura Hexagonal es la mejor decision. Implementar esta arquitecura en algunos otros lenguages como Java o Typescript es bastante intuitivo, con Go no ocurre lo mismo, debido a que Go no cuenta con todas las herramientras de un lenguaje orientado a objetos, sin embargo puede ser implementada con conceptos equivalentes del lenguaje.

Para este blog vamos a crear un backend sencillo usando lo mÃ¡s escencial del lenguaje. Primero necesitamos saber la estrcutura de carpetas que vamos a usar.

![folder-strcutre-go](https://miro.medium.com/max/1028/1*clWgRm1Q_muvVi8XMJ50pw.png)

En Go no tenemos Clases(Class) pero contamos con Estructuras(Structs) y estÃ¡s a su vez cuentan con algo llamado Reciver Functions que seran usados como equivalentes de los MÃ©todos.

Para entender mejor la diferencias revisemos este ejemplo con Typescript y Go

<img
  width="600px"
  src="https://miro.medium.com/max/1400/1*d0URC4Nok-MGJd5ucSD7pw.png"
></img>

Como se puede apreciar en la imagen Go no tiene un constructor de manera explicita como Typescript asi que tenemos que simularlo creando una funciÃ³n que se encargue de devolvernos un Usuario (NewPerson en la imagen del lado izquierdo) y luego creamos un "MÃ©todo" de la "Clase" usando Reciver Functions (GetEmail en la imagen del lado izquierdo). Ahora que tenemos la manera de remplazar las clases podemos empezar a construir nuestra App

### 1. Creando los Dominios(Domains): User

Vamos a usar la estructura previa, crearemos un archivo dentro de la carpeta domain (internal/core/domain) con el nombre de user.go para entender que estarÃ­a en la carpeta domain podemos decir que es analoga a la carpeta "models" o "entitys" de algunos frameworks.

```package domain

    type User struct {
        ID       int
        Email    string
        Password string
    }

    func NewPerson(id int, email string, password string) *User {
        return &User{
            ID:       id,
            Email:    email,
            Password: password,
        }
    }

    func (u *User) GetEmail() string {
        return u.Email
    }

```

### 2. Creando los puertos(Ports): UserRepository, UserService y UserHandlers

Los puertos son las instructiones de como un Servicio o Repositorio debe comportarse, en esta parte le indicaremos mediante interfaces que mÃ©todos debe contener una Estructura(Clase en POO) para ser considerada un Servicio o Repositorio respectivamente.

En go las interfaces trabajan de forma distinta son implicitias eso quiere decir que no tenemos que indicar que estamos implementadola en la declaraciÃ³n lo Ãºnico que debemos hacer es agregar los mÃ©todos y Go automaticamente lo considerara una interfaz vÃ¡lida.

```

    package ports

    import (
        fiber "github.com/gofiber/fiber/v2"
    )

    type UserService interface {
        Login(email string, password string) error
        Register(email string, password string, passwordConfirmation string) error
    }

    type UserRepository interface {
        Login(email string, password string) error
        Register(email string, password string) error
    }

    type UserHandlers interface {
        Login(c *fiber.Ctx) error
        Register(c *fiber.Ctx) error
    }

```

### 3. Creando e Implementando los Servicios(Service): UserService

Ahora gracias a las interfaces sabemos exactamente que mÃ©todos necesitamos crear para nuestro UserService, necesitamos en esta Estructura un mÃ©todo Login y uno Register. Pero para eso necesitamos comunicar Service con el Repository(Estrucura que se encargara de comunicarse con la base de datos) ğŸ¤”... asÃ­ que CÃ³mo lo lograremos? En la estrucura UserService agregaremos que como propiedad debe tener un UserRepository para poder funcionar. Este UserRepository sera requerido en nuestro constructor. [NewUserService(userRepository)]

```

    package services

    import (
        "errors"
        "goHexagonalBlog/internal/core/ports"
    )

    type UserService struct {
        userRepository ports.UserRepository
    }

    //This line is for get feedback in case we are not implementing the interface correctly
    var _ ports.UserService = (*UserService)(nil)

    func NewUserService(repository ports.UserRepository) *UserService {
        return &UserService{
            userRepository: repository,
        }
    }

    func (s *UserService) Login(email string, password string) error {
        err := s.userRepository(email, password)
        if err != nil {
            return err
        }
        return nil
    }

    func (s *UserService) Register(email string, password string, confirmPass string) error {
        if password != confirmPass {
            return errors.New("the passwords are not equal")
        }
        err := s.userRepository.Register(email, password)
        if err != nil {
            return err
        }
        return nil
    }

```

### 4. Creando e Implementando los Repositorios(Repository): UserRepository

El repositorio de usuario se comunicara directamente con la base de datos, asie que en la funcion de creaciÃ³n (NewUserRepository) podemos agregar la inicializaciÃ³n de la base de datos, para este ejemplo usarÃ© mongo.

```

    package repositories

    import (
        "context"
        "time"

        "goHexagonalBlog/internal/core/ports"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.mongodb.org/mongo-driver/mongo/readpref"
    )

    const (
        MongoClientTimeout = 5
    )

    type UserRepository struct {
        client     *mongo.Client
        database   *mongo.Database
        collection *mongo.Collection
    }

    var _ ports.UserRepository = (*UserRepository)(nil)

    func NewUserRepository(conn string) *UserRepository {
        ctx, cancelFunc := context.WithTimeout(context.Background(), MongoClientTimeout*time.Second)
        defer cancelFunc()

        client, err := mongo.Connect(ctx, options.Client().ApplyURI(
            conn,
        ))
        if err != nil {
            return nil, err
        }
        err = client.Ping(ctx, readpref.Primary())
        if err != nil {
            return nil, err
        }
        return &UserRepository{
            client:     client,
            database:   client.Database("goHexagonalBlog"),
            collection: client.Database("goHexagonalBlog").Collection("users"),
        }
    }

    func (r *UserRepository) Login(email string, password string) error {
        //Here your code for login in mongo database
        return nil
    }

    func (r *UserRepository) Register(email string, password string) error {
        //Here your code for save in mongo database
        return nil
    }

```

### 5. Creando los Handlers: UserHandlers

Ahora tenemos que exponer nuestro servicio a los handlers y estos handlers al mundo para eso usaremos GoFiber para los handlers como en las otras implementaciones haremos algo muy parecido pero esta ves UserHandlers requerira de UserService para funcionar ya que los Handlers se comunicaran con los Servicios

```

    package handlers

    import (
        "goHexagonalBlog/internal/core/ports"

        fiber "github.com/gofiber/fiber/v2"
    )

    type UserHandlers struct {
        userService ports.UserService
    }

    var _ ports.UserHandlers = (*UserHandlers)(nil)

    func NewUserHandlers(userService ports.UserService) *UserHandlers {
        return &UserHandlers{
            userService: userService,
        }
    }

    func (h *UserHandlers) Login(c *fiber.Ctx) error {
        var email string
        var password string
        //Extract the body and get the email and password
        err := h.userService.Login(email, password)
        if err != nil {
            return err
        }
        return nil
    }

    func (h *UserHandlers) Register(c *fiber.Ctx) error {
        var email string
        var password string
        var confirmPassword string

        //Extract the body and get the email and password
        err := h.userService.Register(email, password, confirmPassword)
        if err != nil {
            return err
        }
        return nil
    }

```

### 6. Creando el Servidor (Server): Fiber HTTPS server

Luego de tener todas las piezas Lego lista necesitamos crear una ultima parte para inizializar nuestros programa en un servidor HTTPS, continuare usando Fiber para esto, como en las otras partes continuare usando una Estructura para hacer el programa mÃ¡s modular

```

    package server

    import (
        "goHexagonalBlog/internal/core/ports"
        "log"

        fiber "github.com/gofiber/fiber/v2"
    )

    type Server struct {
        //We will add every new Handler here
        userHandlers ports.UserHandlers
        //middlewares ports.Middlewares
        //paymentHandlers ports.PaymentHandlers
    }

    func NewServer(uHandlers ports.UserHandlers) *Server {
        return &Server{
            userHandlers: uHandlers,
            //paymentHandlers: pHandlers
        }
    }

    func (s *Server) Initialize() {
        app := fiber.New()
        v1 := app.Group("/v1")

        userRoutes := v1.Group("/user")
        userRoutes.Post("/login", s.userHandlers.Login)
        userRoutes.Post("/register", s.userHandlers.Register)

        err := app.Listen(":5000")
        if err != nil {
            log.Fatal(err)
        }
    }

```

### 7. QuÃ© comienze la mÃ¡gia!

Finalmente crearemos nuestro punto de entrada en la aplicaciÃ³n en el main.go y entenderemos mejor como esta arquitectura funciona. Recordemos que para crear nuestro UserRepository necesitamos una URL de conexiÃ³n a mongo, para crear nuestro UserService necesitamos un UserRepository, para crear nuestro UserHandler necesitamos un UserService y para crear nuestro servidor necesitamos de los Hanlders.

> **_MongoConn:string > UserRepository > UserService > UserHandler > Server_**

```

    package main

    import (
        "goHexagonalBlog/internal/core/services"
        "goHexagonalBlog/internal/handlers"
        "goHexagonalBlog/internal/repositories"
        "goHexagonalBlog/internal/server"
    )

    func main() {
        mongoConn := "secretğŸ¤«"
        //repositories
        userRepository := repositories.NewUserRepository(mongoConn)
        //services
        userService := services.NewUserService(userRepository)
        //handlers
        userHandlers := handlers.NewUserHandlers(userService)
        //server
        httpServer := server.NewServer(
            userHandlers,
        )
        httpServer.Initialize()
    }

```

### 8. Disfrutar el momento.

Ahora si tenemos nuestra aplicaciÃ³n de go construida usando Arquitectura Hexagonal y Fiber, SubirÃ© el cÃ³digo a Github para que pueda ser usado como plantilla, espero que hayan disfrutado leyendo el articulo y si te gusto dejame un aplauso ğŸ‘€ eso me motivara para seguir compartiendo contenido.

<a href="https://github.com/solrac97gr/goHexagonalBlog" target="_blank" style={{color:"blue"}}>
  https://github.com/solrac97gr/goHexagonalBlog
</a>
