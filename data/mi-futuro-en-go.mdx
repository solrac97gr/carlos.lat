---
title: "Mi futuro con Go para este 2023 游냧"
date: "22 de Marzo del 2023"
published: "2023-03-22"
abstract: "El a침o pasado me dediqu칠 칰nica y exclusivamente a armar la plantilla ideal para mis proyectos, Descubre cu치l es el siguiente paso 游뱂."
image: "https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2FDO9s_gDX0AEsSe8.jpg?alt=media&token=01fd59bd-c226-4cc0-aba1-65e5f845ec48"
tag: "golang, Go"
author: "Carlos Garc칤a"
---

# Mi futuro con Go para este 2023 游냧

<small>22 de Marzo de 2023</small>
<EditPost path="mi-futuro-en-go" />

<img
  width="100%"
  src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2FDO9s_gDX0AEsSe8.jpg?alt=media&token=01fd59bd-c226-4cc0-aba1-65e5f845ec48"
  alt="golang wallpaper"
  style={{ borderRadius: "8px" }}
></img>

El a침o pasado me concentr칠 en encontrar la arquitectura y distribuci칩n ideal para mis proyectos, como resultado de esto sali칩 mi plantilla actual con la que empiezo proyectos en Go, ya qu칠 esta tiene una base ya construida que nos incluye: login con JWT, Documentaci칩n con Swagger, M칠tricas, Generaci칩n de Mocks, etc. Pueden revisarla m치s a detalle en el siguiente link plantilla 2023.

Este a침o me propuse a mejorar en la modularidad, en pocas palabras decid칤 dividir mi plantilla en peque침os paquetes que pudiese reutilizar esto debido a que usualmente tengo proyectos que ya no son solo Web si no tambi칠n CLI y hay partes de mi plantilla web que me gustar칤a usar como el Validador o el Session Manager. Podr칤a copiar y pegar el c칩digo a otro proyecto pero...

Este es el plan

1. Identificar todo posible paquete dentro de mi plantilla que pueda ser reutilizable y aplicable en otro contexto.
2. Desarrollar un paquete que lo mimetice en su comportamiento y estructura.
3. Documentar y Probar el paquete hasta llegar a m칤nimo un 90% de Coverage
4. A finales de a침o actualizar mi nueva plantilla de 2024 que sea 100 modular

## Ventajas de atomizar nuestros paquetes

- Desde ahora los paquetes servir치n a su prop칩sito y nada m치s, esto quiere decir que al estar en un contexto aislado cuando estos sean modificados no interferir치 un sesgo del proyecto en el que se encuentre

  > (Paquete Validator en una app web) Bueno en este spring agregaremos una funci칩n para validar los campos de esta estructura que nos llegar치 como body de la funci칩n X, agregu칠mosla al validador.

  Si bien es una validaci칩n ya lleva una capa de sesgo por ejemplo de que me sirve tener esa funci칩n de validaci칩n en el paquete validator que ser치 usado solo por esa estructura espec칤fica mejor usemos las funciones b치sicas que tiene ya el validador para validar la estructura sin comprometer la funci칩n b치sica del paquete.

  ```go
  package validator

  import errors

  func ValidateHeadersOfBuyShoesRequest(h *HeadersShoes) error{
    if h.authorization!= "my secret 游뱖 " {
      return errors.New("Error validating the authorization")
    }
  }

  ```

  En lugar de contaminar el paquete validator con una funci칩n tan especifica aprovecharemos c칩mo est치 construido en mi plantilla para que sea la estructura la que sea la que agrupe las reglas de validaci칩n

  ```go
  package validator

  type Validator interface {
    Struct(s EvaluableStruct) error
  }

  type EvaluableStruct interface {
    Validate(args...interface{}) error
  }

  type ValidatorImpl struct {}

  func (v *ValidatorImpl) Struct(s EvaluableStruct) error {
    // another logic for only structs
    return s.validate()
  }
  ```

  ```go
  package models

  type HeadersShoesRequest struct {
    Authorization string
    ClientID int
  }

  // The validations are always close with the struct who validates
  func (h *HeadersShoesRequest) Validate(args ...interface{}) error{
    if err := validations.IsEquals(h.Authorization,args[0]); err != nil {
      // use the generic error or be more specific for the example I will use the generic
      return err
    }

    if err := validations.GreaterThan(ClientID,-1); err != nil {
      return err
    }
  }

  ```

  > Considera que el paquete validations es parte del paquete validator

- Prueba una sola vez ya perd칤 la cuenta cuantos Test hago que prueban cosas que sin exactamente lo mismo que en alg칰n otro proyecto, por ejemplo:

  > Necesitamos que el session manager tambi칠n tenga los test para validar que se guard칩 la sesi칩n de forma correcta en el proyecto A,B y C

  쮻onde queda entonces el DRY? Incluso si es en proyectos distintos al atomizar en paquetes peque침os que sirven a su prop칩sito de forma clara y no hacen nada m치s de lo que prometen nos permiten tener Test escritos una sola vez y por tanto pondremos m치s atenci칩n al detalle para hacerlos de calidad, nuestra mente pensar치 solo en la funcionalidad de la funci칩n valga la redundancia, no habr치 sesgo o ruido externo que nos confunda en el prop칩sito de la funci칩n debido a que solo es el paquete 游닍.

- La facilidad de compartir paquetes entre miembros del equipo termina generando un est치ndar en el c칩mo se hacen las cosas ya que todo sus proyectos estar치n armados de la base de los mismos bloques de lego. Imag칤nense algo as칤.

  <img
    width="100%"
    src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2Fatomic-packages.png?alt=media&token=1791bc97-b2c4-4c56-aee8-0b2d75044b4a"
    alt="invoice example"
    style={{ borderRadius: "8px" }}
  ></img>

- Inicias m치s f치ciles y menos abrupto habr치 menos que preguntar te pongo un ejemplo.

  > Hola Carlos, el Lunes entra un nuevo programador al equipo puedes ayudarlo con el OnBoarding t칠cnico.

  > Bienvenido X tu proyecto es Y entonces creo que para empezar podr칤as traer lo siguientes paquetes a tu proyecto que te ser치n 칰tiles: Session Manager, Validator, Logger, Authentication, etc. La documentaci칩n se encuentra en los mismos repositorios.

  Le acabamos de ahorrar probablemente una semana de trabajo en puro boilerplate y probablemente otra semana extra en solo tests.

  Sin mencionar que tener un paquete que se encargue solo de la autentificaci칩n permite que una de las partes m치s cr칤ticas y estresantes dir칤a yo para alguien que se une a la empresa quedar칤a reducido a usar un Middleware que ya fue programado y es pr치cticamente un "Plug and Play"

- Nos permite aislar l칩gica de negocio cr칤tica como lo es la autenticaci칩n en un solo responsable que se encargar치 de velar por la seguridad de ese paquete y al estar aislado de concentrarse en lo que importa que es hacerlo m치s seguro.
- Nos permite tambi칠n aislar l칩gica de negocio cambiante algo muy com칰n en startups qu칠 hay partes del negocio que siguen en estado de prueba e iteraciones pongamos de ejemplo de nuevo el paquete de autenticaci칩n

  > Tenemos que agregar un nuevo cifrado a nuestras claves comuniquen a todos los proyectos sue usen autenticaci칩n que deben agregar la siguiente regla X

  > Hola 쯖칩mo va la adici칩n de la nueva regla? El proyecto A,B ya fue modificado pero no pueden ser lanzados debido a que el proyecto C que se conecta con el A esta a칰n atrasado y debemos terminar esto antes de agregar la nueva regla de seguridad

  쮼ntienden m치s o menos lo que quiero decir? Ahora c칩mo ser칤a si la autenticaci칩n fuera un paquete aislado, la charla cambiar칤a un poco.

  > Comuniquen al encargado del paquete de autenticaci칩n que debemos agregar una nueva regla

  > Hola 쮺칩mo va la adici칩n de la nueva regla de seguridad? Ya se termino de agregar se hizo un release hoy y todos los proyectos involucrados crear치n una rama de su versi칩n m치s estable en su proyecto y agregaron el update de forma inmediata

## Como siempre no todos es color rosa

Hay un riesgo elevado de caer en algo que es muy com칰n en micro servicios que es tener 200 micro servicios y 5 personas que los mantengan definitivamente podr칤amos tener 200 paquetes y solo 5 personas que los mantengan.

Otro punto a tener en cuenta es que creemos un paquete aislado de cada parte de nuestro proyecto , yo creo que si un paquete no es 칰til en al menos m치s del 60% de los proyectos quiz치s es mejor mantenerlos en los proyectos

A menos que te sobren manos entonces me ir칤a 100% a seguir otra regla 쮼ste paquete soluciona un problema com칰n de mi negocio o es una parte cambiante de mi negocio ? Si la respuesta es si es mejor tenerlo en un paquete.

## Mi conclusi칩n personal

Cada uno conoce su flujo de trabajo si sientes que cada vez m치s tedioso iniciar un proyecto de 0 por el tiempo que le inviertes en hacer el Boilerplate inicial te dar치s cuenta que partes son las que m치s se repiten y podr치s identificarlas y volverlas un paquete que te ahorrar치 mucho tiempo.

Hay una raz칩n por la cual los boilerplates son tan populares y suele ser por dos razones seg칰n mi punto de vista.

- No saber por donde empezar.
- Estar cansado de programar lo mismo cada que inicias un nuevo proyecto.

Y generar estos paquetes at칩micos te dar치 la libertad de solo escoger las partes que necesitas, en lo personal soy una persona que le gusta mucho programar cosas Open Source y este m칠todo me ayuda a que peque침as partes de mis plantillas puedan ser usadas sin necesidad de usar el 100 de esta.

Este a침o que transcurre actualmente me dedicar칠 a atomizar todos mis paquetes que se repiten para que el a침o que entra pueda usar la plantilla armada con los bloques que cree este a침o y crear un cliente que te deje escoger partes de la plantilla mejorando en tama침o del proyecto para el 2024.

Les dejo unos links a los paquetes que ya estoy desarrollando por si quieren colaborar son cosas simples as칤 que es ideal si quieres empezar en el mundo de open source:

- <BlogLink
    url="https://github.com/solrac97gr/session-manager"
    content="github.com/session-manager"
  />
- <BlogLink
    url="https://github.com/solrac97gr/validator"
    content="github.com/validator"
  />

Y este es el link a mi plantilla actual usa Fiber, Mongo y autenticaci칩n con JWT

- <BlogLink
    url="https://github.com/solrac97gr/go-jwt-auth"
    content="github.com/go-jwt-auth"
  />
