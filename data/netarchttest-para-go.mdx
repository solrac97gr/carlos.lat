---
title: "NetArchTest para Go? GoArchTest: conserva tu arquitectura ğŸ—ï¸"
date: "13 de Junio del 2025"
published: "2025-06-13"
abstract: "Descubre cÃ³mo GoArchTest te ayuda a mantener una arquitectura sÃ³lida en Go, detectando violaciones que el compilador no puede encontrar."
image: "https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2FFUAQvEkXoAAuQ-2.jpg-large.jpeg?alt=media&token=959951bf-5f60-4ecd-9ddf-74511f0ff3fa"
tag: "Go, Hexagonal, Clean, DDD"
author: "Carlos GarcÃ­a"
---

# NetArchTest para Go? GoArchTest: conserva tu arquitectura ğŸ—ï¸

<small>13 de Junio del 2025</small>
<EditPost path="goarchtest-arquitectura-go-limpia" />

<img
  width="100%"
  alt="GoArchTest - Arquitectura Go limpia"
  src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2FFUAQvEkXoAAuQ-2.jpg-large.jpeg?alt=media&token=959951bf-5f60-4ecd-9ddf-74511f0ff3fa"
  style={{ borderRadius: "8px" }} />

Â¿Alguna vez te has preguntado por quÃ© tu cÃ³digo Go compila perfectamente pero tu arquitectura se deteriora con el tiempo? El compilador de Go previene los ciclos de importaciÃ³n, pero no puede detectar violaciones arquitectÃ³nicas mÃ¡s sutiles. AquÃ­ es donde entra **GoArchTest**, una biblioteca que te permite definir y hacer cumplir reglas arquitectÃ³nicas en tus proyectos Go.

En este post, te mostrarÃ© cÃ³mo usar GoArchTest para mantener tu cÃ³digo Go organizado y arquitectÃ³nicamente correcto, especialmente cuando trabajas con patrones como Clean Architecture y Domain-Driven Design.

## Â¿Por quÃ© necesitas GoArchTest si Go ya previene los ciclos de importaciÃ³n?

Esta es la pregunta del millÃ³n. Aunque Go previene esto:

<CodeSnippet language={"go"} route={"paquete_a.go"} code={`// âŒ Go compiler ERROR: import cycle
package A
import "B"  // A â†’ B

package B  
import "A"  // B â†’ A (ERROR: import cycle)`} />

Go **SÃ permite** esto (pero viola Clean Architecture):

<CodeSnippet language={"go"} route={"domain.go"} code={`// âœ… Go compiler: Compila bien
// âŒ Clean Architecture: VIOLACIÃ“N
package domain
import "infrastructure"  // Capa interna dependiendo de capa externa

package infrastructure
import "domain"  // Esto sÃ­ estÃ¡ correcto en Clean Architecture`} />

**GoArchTest** llena este vacÃ­o detectando violaciones arquitectÃ³nicas que Go no puede verificar.

## InstalaciÃ³n y configuraciÃ³n inicial

Primero, instala GoArchTest en tu proyecto:

<CodeSnippet language={"bash"} code={`go get github.com/solrac97gr/goarchtest`} />

## 1. Ejemplo bÃ¡sico: SeparaciÃ³n de capas

Empecemos con un ejemplo sencillo donde queremos asegurar que la capa de presentaciÃ³n no dependa directamente de la capa de datos:

<CodeSnippet language={"go"} route={"architecture_test.go"} code={`package main_test

import (
    "testing"
    "path/filepath"
    
    "github.com/solrac97gr/goarchtest"
)

func TestArchitecture(t *testing.T) {
    // Obtener la ruta del proyecto
    projectPath, _ := filepath.Abs("./")
    
    // Crear instancia de GoArchTest
    types := goarchtest.InPath(projectPath)
    
    // Regla: presentaciÃ³n no debe depender de datos
    result := types.
        That().
        ResideInNamespace("presentation").
        ShouldNot().
        HaveDependencyOn("data").
        GetResult()
        
    if !result.IsSuccessful {
        t.Error("âŒ ViolaciÃ³n: La capa de presentaciÃ³n depende de datos")
        for _, failingType := range result.FailingTypes {
            t.Logf("ViolaciÃ³n en: %s (%s)", failingType.Name, failingType.Package)
        }
    }
}`} />

## 2. Validando Clean Architecture completa

GoArchTest incluye patrones predefinidos para arquitecturas comunes. AquÃ­ tienes cÃ³mo validar Clean Architecture:

<CodeSnippet language={"go"} route={"clean_arch_test.go"} code={`func TestCleanArchitecture(t *testing.T) {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Definir el patrÃ³n de Clean Architecture
    cleanArchPattern := goarchtest.CleanArchitecture(
        "domain",        // Capa de dominio
        "application",   // Capa de aplicaciÃ³n  
        "infrastructure", // Capa de infraestructura
        "presentation",  // Capa de presentaciÃ³n
    )
    
    // Validar todas las reglas
    validationResults := cleanArchPattern.Validate(types)
    
    // Verificar resultados
    passedRules := 0
    for i, result := range validationResults {
        if result.IsSuccessful {
            passedRules++
            t.Logf("âœ… Regla #%d: EXITOSA", i+1)
        } else {
            t.Errorf("âŒ Regla #%d: FALLA", i+1)
            for _, failingType := range result.FailingTypes {
                t.Logf("   ViolaciÃ³n: %s (%s)", failingType.Name, failingType.Package)
            }
        }
    }
    
    t.Logf("Resumen: %d/%d reglas pasaron", passedRules, len(validationResults))
}`} />


## 3. Domain-Driven Design con Clean Architecture

Para proyectos mÃ¡s complejos que usan DDD, GoArchTest soporta mÃºltiples contextos delimitados (bounded contexts):

<CodeSnippet language={"go"} route={"ddd_test.go"} code={`func TestDDDArchitecture(t *testing.T) {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Definir dominios (bounded contexts)
    domains := []string{"user", "products", "orders"}
    
    // PatrÃ³n DDD con Clean Architecture
    dddPattern := goarchtest.DDDWithCleanArchitecture(
        domains,           // Lista de dominios
        "internal/shared", // Kernel compartido
        "pkg",            // Utilidades
    )
    
    validationResults := dddPattern.Validate(types)
    
    // Verificar aislamiento entre dominios
    for i, result := range validationResults {
        if !result.IsSuccessful {
            t.Errorf("âŒ Regla DDD #%d falla", i+1)
            for _, failingType := range result.FailingTypes {
                t.Logf("ViolaciÃ³n: %s (%s)", failingType.Name, failingType.Package)
            }
        }
    }
}`} />

Estructura de proyecto DDD tÃ­pica:

<FolderStructure
  repo="https://github.com/solrac97gr/goarchtest/"
  tree={[
    {
      type: "folder",
      name: "internal",
      content: [
        {
          type: "folder",
          name: "user",
          content: [
            {
              type: "folder",
              name: "domain",
            },
            {
              type: "folder",
              name: "application", 
            },
            {
              type: "folder",
              name: "infrastructure",
            }
          ]
        },
        {
          type: "folder",
          name: "products",
          content: [
            {
              type: "folder",
              name: "domain"
            },
            {
              type: "folder",
              name: "application"
            },
            {
              type: "folder",
              name: "infrastructure"
            }
          ]
        },
        {
          type: "folder",
          name: "shared",
        }
      ]
    },
    {
      type: "folder",
      name: "pkg",
      content: [
        {
          type: "folder",
          name: "logger"
        }
      ]
    }
  ]}
/>

## 4. Reglas personalizadas para tu proyecto

Puedes crear reglas especÃ­ficas para tu proyecto usando predicados personalizados:

<CodeSnippet language={"go"} route={"custom_rules_test.go"} code={`func TestCustomRules(t *testing.T) {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Regla personalizada: Servicios deben terminar en "Service"
    isServiceImplementation := func(typeInfo *goarchtest.TypeInfo) bool {
        return typeInfo.IsStruct && 
               len(typeInfo.Name) > 7 && 
               typeInfo.Name[len(typeInfo.Name)-7:] == "Service"
    }
    
    result := types.
        That().
        WithCustomPredicate("IsServiceImplementation", isServiceImplementation).
        Should().
        ResideInNamespace("application").
        GetResult()
        
    if !result.IsSuccessful {
        t.Error("âŒ Los servicios deben estar en la capa de aplicaciÃ³n")
    }
}`} />

## 5. VisualizaciÃ³n de dependencias

GoArchTest puede generar grÃ¡ficos de dependencias para visualizar tu arquitectura:

<CodeSnippet language={"go"} route={"graph_generation.go"} code={`func GenerateDependencyGraph() {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Crear reportero
    reporter := goarchtest.NewErrorReporter(os.Stderr)
    
    // Obtener todos los tipos
    allTypes := types.That().GetAllTypes()
    
    // Generar grÃ¡fico DOT
    err := reporter.SaveDependencyGraph(allTypes, "dependency_graph.dot")
    if err != nil {
        log.Printf("Error generando grÃ¡fico: %v", err)
        return
    }
    
    log.Println("GrÃ¡fico guardado en: dependency_graph.dot")
    log.Println("Para generar PNG: dot -Tpng dependency_graph.dot -o dependency_graph.png")
}`} />

## 6. IntegraciÃ³n con CI/CD

Para mantener tu arquitectura limpia automÃ¡ticamente, agrega los tests a tu pipeline:

<CodeSnippet language={"yaml"} route={".github/workflows/architecture.yml"} code={`name: Architecture Tests

on: [push, pull_request]

jobs:
  architecture:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21
        
    - name: Run Architecture Tests
      run: |
        go test -v ./tests/architecture/
        
    - name: Generate Dependency Graph
      run: |
        go run cmd/graph/main.go
        
    - name: Upload Architecture Report
      uses: actions/upload-artifact@v3
      with:
        name: architecture-report
        path: dependency_graph.png`} />

## Beneficios reales en equipos de desarrollo

### ğŸš€ **PrevenciÃ³n de deterioro arquitectÃ³nico**
- Detecta violaciones antes de que lleguen a producciÃ³n
- Mantiene la consistencia entre diferentes desarrolladores
- Evita la "deuda tÃ©cnica" arquitectÃ³nica

### ğŸ“š **DocumentaciÃ³n viva**
- Los tests sirven como documentaciÃ³n ejecutable
- Nuevos desarrolladores entienden la arquitectura leyendo los tests
- Las reglas estÃ¡n siempre actualizadas

### ğŸ”§ **Escalabilidad**
- Facilita la divisiÃ³n de dominios en microservicios
- Mantiene lÃ­mites claros entre contextos
- Reduce el acoplamiento entre componentes

## Comparativa: Go vs GoArchTest

### ğŸ”§ **Compilador Go**
- âœ… **Dependencias circulares**: Previene automÃ¡ticamente los ciclos de importaciÃ³n
- âŒ **Violaciones de capas**: Permite que cualquier capa dependa de cualquier otra
- âŒ **DirecciÃ³n de dependencias**: No controla el flujo arquitectÃ³nico
- âŒ **Aislamiento de dominios**: Sin reglas para separar contextos de negocio
- âŒ **Consistencia en equipo**: ValidaciÃ³n manual y propensa a errores

### ğŸ—ï¸ **GoArchTest**
- ğŸŸ¡ **Dependencias circulares**: No necesario (ya lo maneja Go)
- âœ… **Violaciones de capas**: Detecta y previene violaciones arquitectÃ³nicas
- âœ… **DirecciÃ³n de dependencias**: Controla el flujo segÃºn Clean Architecture
- âœ… **Aislamiento de dominios**: Configurable para Domain-Driven Design
- âœ… **Consistencia en equipo**: Automatizado mediante tests ejecutables

## ConclusiÃ³n

GoArchTest es una herramienta esencial para cualquier proyecto Go que quiera mantener una arquitectura sÃ³lida y escalable. No reemplaza las protecciones del compilador, sino que las complementa con validaciones arquitectÃ³nicas que van mÃ¡s allÃ¡ de lo que Go puede verificar.

Al implementar GoArchTest en tu proyecto, lograrÃ¡s:
- **Arquitectura consistente** en todo el equipo
- **DetecciÃ³n temprana** de violaciones arquitectÃ³nicas  
- **DocumentaciÃ³n ejecutable** de tus decisiones de diseÃ±o
- **Base sÃ³lida** para escalar tu aplicaciÃ³n

Â¿Ya usas alguna herramienta para validar arquitectura en tus proyectos Go? Â¡CuÃ©ntame en los comentarios cÃ³mo mantienes tu cÃ³digo organizado!

---

**ğŸ’¡ Tip extra:** Combina GoArchTest con herramientas de anÃ¡lisis estÃ¡tico como `golangci-lint` para tener una validaciÃ³n completa de tu cÃ³digo Go.

**ğŸ”— Enlaces Ãºtiles:**
- [Repositorio de GoArchTest](https://github.com/solrac97gr/goarchtest)
- [DocumentaciÃ³n completa](https://github.com/solrac97gr/goarchtest#readme)
- [Ejemplos prÃ¡cticos](https://github.com/solrac97gr/goarchtest/tree/main/examples)
