---
title: "NetArchTest para Go? GoArchTest: conserva tu arquitectura üèóÔ∏è"
date: "13 de Junio del 2025"
published: "2025-06-13"
abstract: "Descubre c√≥mo GoArchTest te ayuda a mantener una arquitectura s√≥lida en Go, detectando violaciones que el compilador no puede encontrar."
image: "https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2FFUAQvEkXoAAuQ-2.jpg-large.jpeg?alt=media&token=959951bf-5f60-4ecd-9ddf-74511f0ff3fa"
tag: "Go, Hexagonal, Clean, DDD"
author: "Carlos Garc√≠a"
---

# NetArchTest para Go? GoArchTest: conserva tu arquitectura üèóÔ∏è

<small>13 de Junio del 2025</small>
<EditPost path="goarchtest-arquitectura-go-limpia" />

<img
  width="100%"
  alt="GoArchTest - Arquitectura Go limpia"
  src="https://firebasestorage.googleapis.com/v0/b/portfolio-18ce8.appspot.com/o/images%2FFUAQvEkXoAAuQ-2.jpg-large.jpeg?alt=media&token=959951bf-5f60-4ecd-9ddf-74511f0ff3fa"
  style={{ borderRadius: "8px" }} />

¬øAlguna vez te has preguntado por qu√© tu c√≥digo Go compila perfectamente pero tu arquitectura se deteriora con el tiempo? El compilador de Go previene los ciclos de importaci√≥n, pero no puede detectar violaciones arquitect√≥nicas m√°s sutiles. Aqu√≠ es donde entra **GoArchTest**, una biblioteca que te permite definir y hacer cumplir reglas arquitect√≥nicas en tus proyectos Go.

En este post, te mostrar√© c√≥mo usar GoArchTest para mantener tu c√≥digo Go organizado y arquitect√≥nicamente correcto, especialmente cuando trabajas con patrones como Clean Architecture y Domain-Driven Design.

## ¬øPor qu√© necesitas GoArchTest si Go ya previene los ciclos de importaci√≥n?

Esta es la pregunta del mill√≥n. Aunque Go previene esto:

<CodeSnippet language={"go"} route={"paquete_a.go"} code={`// ‚ùå Go compiler ERROR: import cycle
package A
import "B"  // A ‚Üí B

package B  
import "A"  // B ‚Üí A (ERROR: import cycle)`} />

Go **S√ç permite** esto (pero viola Clean Architecture):

<CodeSnippet language={"go"} route={"domain.go"} code={`// ‚úÖ Go compiler: Compila bien
// ‚ùå Clean Architecture: VIOLACI√ìN
package domain
import "infrastructure"  // Capa interna dependiendo de capa externa

package infrastructure
import "domain"  // Esto s√≠ est√° correcto en Clean Architecture`} />

**GoArchTest** llena este vac√≠o detectando violaciones arquitect√≥nicas que Go no puede verificar.

## Instalaci√≥n y configuraci√≥n inicial

Primero, instala GoArchTest en tu proyecto:

<CodeSnippet language={"bash"} code={`go get github.com/solrac97gr/goarchtest`} />

## 1. Ejemplo b√°sico: Separaci√≥n de capas

Empecemos con un ejemplo sencillo donde queremos asegurar que la capa de presentaci√≥n no dependa directamente de la capa de datos:

<CodeSnippet language={"go"} route={"architecture_test.go"} code={`package main_test

import (
    "testing"
    "path/filepath"
    
    "github.com/solrac97gr/goarchtest"
)

func TestArchitecture(t *testing.T) {
    // Obtener la ruta del proyecto
    projectPath, _ := filepath.Abs("./")
    
    // Crear instancia de GoArchTest
    types := goarchtest.InPath(projectPath)
    
    // Regla: presentaci√≥n no debe depender de datos
    result := types.
        That().
        ResideInNamespace("presentation").
        ShouldNot().
        HaveDependencyOn("data").
        GetResult()
        
    if !result.IsSuccessful {
        t.Error("‚ùå Violaci√≥n: La capa de presentaci√≥n depende de datos")
        for _, failingType := range result.FailingTypes {
            t.Logf("Violaci√≥n en: %s (%s)", failingType.Name, failingType.Package)
        }
    }
}`} />

## 2. Validando Clean Architecture completa

GoArchTest incluye patrones predefinidos para arquitecturas comunes. Aqu√≠ tienes c√≥mo validar Clean Architecture:

<CodeSnippet language={"go"} route={"clean_arch_test.go"} code={`func TestCleanArchitecture(t *testing.T) {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Definir el patr√≥n de Clean Architecture
    cleanArchPattern := goarchtest.CleanArchitecture(
        "domain",        // Capa de dominio
        "application",   // Capa de aplicaci√≥n  
        "infrastructure", // Capa de infraestructura
        "presentation",  // Capa de presentaci√≥n
    )
    
    // Validar todas las reglas
    validationResults := cleanArchPattern.Validate(types)
    
    // Verificar resultados
    passedRules := 0
    for i, result := range validationResults {
        if result.IsSuccessful {
            passedRules++
            t.Logf("‚úÖ Regla #%d: EXITOSA", i+1)
        } else {
            t.Errorf("‚ùå Regla #%d: FALLA", i+1)
            for _, failingType := range result.FailingTypes {
                t.Logf("   Violaci√≥n: %s (%s)", failingType.Name, failingType.Package)
            }
        }
    }
    
    t.Logf("Resumen: %d/%d reglas pasaron", passedRules, len(validationResults))
}`} />


## 3. Domain-Driven Design con Clean Architecture

Para proyectos m√°s complejos que usan DDD, GoArchTest soporta m√∫ltiples contextos delimitados (bounded contexts):

<CodeSnippet language={"go"} route={"ddd_test.go"} code={`func TestDDDArchitecture(t *testing.T) {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Definir dominios (bounded contexts)
    domains := []string{"user", "products", "orders"}
    
    // Patr√≥n DDD con Clean Architecture
    dddPattern := goarchtest.DDDWithCleanArchitecture(
        domains,           // Lista de dominios
        "internal/shared", // Kernel compartido
        "pkg",            // Utilidades
    )
    
    validationResults := dddPattern.Validate(types)
    
    // Verificar aislamiento entre dominios
    for i, result := range validationResults {
        if !result.IsSuccessful {
            t.Errorf("‚ùå Regla DDD #%d falla", i+1)
            for _, failingType := range result.FailingTypes {
                t.Logf("Violaci√≥n: %s (%s)", failingType.Name, failingType.Package)
            }
        }
    }
}`} />

Estructura de proyecto DDD t√≠pica:

<FolderStructure
  repo="https://github.com/solrac97gr/goarchtest/"
  tree={[
    {
      type: "folder",
      name: "internal",
      content: [
        {
          type: "folder",
          name: "user",
          content: [
            {
              type: "folder",
              name: "domain",
            },
            {
              type: "folder",
              name: "application", 
            },
            {
              type: "folder",
              name: "infrastructure",
            }
          ]
        },
        {
          type: "folder",
          name: "products",
          content: [
            {
              type: "folder",
              name: "domain"
            },
            {
              type: "folder",
              name: "application"
            },
            {
              type: "folder",
              name: "infrastructure"
            }
          ]
        },
        {
          type: "folder",
          name: "shared",
        }
      ]
    },
    {
      type: "folder",
      name: "pkg",
      content: [
        {
          type: "folder",
          name: "logger"
        }
      ]
    }
  ]}
/>

## 4. Reglas personalizadas para tu proyecto

Puedes crear reglas espec√≠ficas para tu proyecto usando predicados personalizados:

<CodeSnippet language={"go"} route={"custom_rules_test.go"} code={`func TestCustomRules(t *testing.T) {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Regla personalizada: Servicios deben terminar en "Service"
    isServiceImplementation := func(typeInfo *goarchtest.TypeInfo) bool {
        return typeInfo.IsStruct && 
               len(typeInfo.Name) > 7 && 
               typeInfo.Name[len(typeInfo.Name)-7:] == "Service"
    }
    
    result := types.
        That().
        WithCustomPredicate("IsServiceImplementation", isServiceImplementation).
        Should().
        ResideInNamespace("application").
        GetResult()
        
    if !result.IsSuccessful {
        t.Error("‚ùå Los servicios deben estar en la capa de aplicaci√≥n")
    }
}`} />

## 5. Visualizaci√≥n de dependencias

GoArchTest puede generar gr√°ficos de dependencias para visualizar tu arquitectura:

<CodeSnippet language={"go"} route={"graph_generation.go"} code={`func GenerateDependencyGraph() {
    projectPath, _ := filepath.Abs("./")
    types := goarchtest.InPath(projectPath)
    
    // Crear reportero
    reporter := goarchtest.NewErrorReporter(os.Stderr)
    
    // Obtener todos los tipos
    allTypes := types.That().GetAllTypes()
    
    // Generar gr√°fico DOT
    err := reporter.SaveDependencyGraph(allTypes, "dependency_graph.dot")
    if err != nil {
        log.Printf("Error generando gr√°fico: %v", err)
        return
    }
    
    log.Println("Gr√°fico guardado en: dependency_graph.dot")
    log.Println("Para generar PNG: dot -Tpng dependency_graph.dot -o dependency_graph.png")
}`} />

## 6. Integraci√≥n con CI/CD

Para mantener tu arquitectura limpia autom√°ticamente, agrega los tests a tu pipeline:

<CodeSnippet language={"yaml"} route={".github/workflows/architecture.yml"} code={`name: Architecture Tests

on: [push, pull_request]

jobs:
  architecture:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21
        
    - name: Run Architecture Tests
      run: |
        go test -v ./tests/architecture/
        
    - name: Generate Dependency Graph
      run: |
        go run cmd/graph/main.go
        
    - name: Upload Architecture Report
      uses: actions/upload-artifact@v3
      with:
        name: architecture-report
        path: dependency_graph.png`} />

## Beneficios reales en equipos de desarrollo

### üöÄ **Prevenci√≥n de deterioro arquitect√≥nico**
- Detecta violaciones antes de que lleguen a producci√≥n
- Mantiene la consistencia entre diferentes desarrolladores
- Evita la "deuda t√©cnica" arquitect√≥nica

### üìö **Documentaci√≥n viva**
- Los tests sirven como documentaci√≥n ejecutable
- Nuevos desarrolladores entienden la arquitectura leyendo los tests
- Las reglas est√°n siempre actualizadas

### üîß **Escalabilidad**
- Facilita la divisi√≥n de dominios en microservicios
- Mantiene l√≠mites claros entre contextos
- Reduce el acoplamiento entre componentes

## Comparativa: Go vs GoArchTest

### üîß **Compilador Go**
- ‚úÖ **Dependencias circulares**: Previene autom√°ticamente los ciclos de importaci√≥n
- ‚ùå **Violaciones de capas**: Permite que cualquier capa dependa de cualquier otra
- ‚ùå **Direcci√≥n de dependencias**: No controla el flujo arquitect√≥nico
- ‚ùå **Aislamiento de dominios**: Sin reglas para separar contextos de negocio
- ‚ùå **Consistencia en equipo**: Validaci√≥n manual y propensa a errores

### üèóÔ∏è **GoArchTest**
- üü° **Dependencias circulares**: No necesario (ya lo maneja Go)
- ‚úÖ **Violaciones de capas**: Detecta y previene violaciones arquitect√≥nicas
- ‚úÖ **Direcci√≥n de dependencias**: Controla el flujo seg√∫n Clean Architecture
- ‚úÖ **Aislamiento de dominios**: Configurable para Domain-Driven Design
- ‚úÖ **Consistencia en equipo**: Automatizado mediante tests ejecutables

## Conclusi√≥n

GoArchTest es una herramienta esencial para cualquier proyecto Go que quiera mantener una arquitectura s√≥lida y escalable. No reemplaza las protecciones del compilador, sino que las complementa con validaciones arquitect√≥nicas que van m√°s all√° de lo que Go puede verificar.

Al implementar GoArchTest en tu proyecto, lograr√°s:
- **Arquitectura consistente** en todo el equipo
- **Detecci√≥n temprana** de violaciones arquitect√≥nicas  
- **Documentaci√≥n ejecutable** de tus decisiones de dise√±o
- **Base s√≥lida** para escalar tu aplicaci√≥n

¬øYa usas alguna herramienta para validar arquitectura en tus proyectos Go? ¬°Cu√©ntame en los comentarios c√≥mo mantienes tu c√≥digo organizado!

---

**üí° Tip extra:** Combina GoArchTest con herramientas de an√°lisis est√°tico como `golangci-lint` para tener una validaci√≥n completa de tu c√≥digo Go.

**üîó Enlaces √∫tiles:**
- [Repositorio de GoArchTest](https://github.com/solrac97gr/goarchtest)
- [Documentaci√≥n completa](https://github.com/solrac97gr/goarchtest#readme)
- [Ejemplos pr√°cticos](https://github.com/solrac97gr/goarchtest/tree/main/examples)
