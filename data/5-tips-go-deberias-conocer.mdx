---
title: "5 trucos y consejos √∫tiles para Go que deber√≠as conocer üêπ"
date: "21 de Julio del 2022"
published: "2022-07-21"
abstract: "En este post, voy a mostrarles 5 trucos que uso en mi d√≠a a d√≠a como programador remoto de Go."
image: "https://miro.medium.com/max/1400/1*0xwMiyD3YFwIsfk-ZREGNQ.png"
tag: "Go"
author: "Carlos Garc√≠a"
---

# 5 trucos y consejos √∫tiles para Go que deber√≠as conocer üêπ

<small>21 de Julio del 2022</small><EditPost path="5-tips-go-deberias-conocer" />

<img width="100%" alt="golang-wallpaper " src="https://miro.medium.com/max/1400/1*0xwMiyD3YFwIsfk-ZREGNQ.png"/>

Go es uno de los lenguajes de programaci√≥n m√°s √∫tiles para realizar diferentes tareas, en especial,  tareas de concurrencia. Adem√°s, todas las bibliotecas nativas de este lenguaje tienen muchas funciones comunes que necesitamos a diario.
En este post, voy a mostrarles 5 trucos que uso en mi d√≠a a d√≠a como programador remoto de Go.

## 1. Tiempo de ejecuci√≥n de un c√≥digo
Go sobresale por su gran rendimiento y as√≠ ha logrado ser uno de los lenguajes de programaci√≥n m√°s usados. Por ello, una de las cosas que hago todos los d√≠as es medir el tiempo de ejecuci√≥n de mi c√≥digo en Go. Puedes usar una funci√≥n y a√±adirla en la instrucci√≥n defer para mejorar la comprensi√≥n.

```go
  package main

  import (
	  "log"
	  "time"
  )

  func ExecTime(start time.Time, name string) {
	  elapsed := time.Since(start)
	  log.Printf("%s took %s", name, elapsed)
  }

  func main() {
	  defer ExecTime(time.Now(), "main")
	  time.Sleep(3 * time.Second)
  }

```

## 2. Serializar (marshalling) un Json string con un Struct no definido a un "Objeto"
Este es un problema com√∫n en el Log de un sistema cuando guardamos una Respuesta y una Petici√≥n con un struct no definido y necesitamos manipular la informaci√≥n dentro de este string.

```go
  package main

  import (
	  "encoding/json"
	  "fmt"
	  "time"
  )

  type LogRegister struct {
	  ID            int
	  RequestString string
	  RequestJson   map[string]interface{}
	  CreatedAt     time.Time
	  UpdatedAt     time.Time
  }

  func (c *LogRegister) FormatStringToJson() {
	  var request map[string]interface{}

	  json.Unmarshal([]byte(c.RequestString), &request)

	  c.RequestJson = request
  }

  func main() {
	  logRegister := LogRegister{
		  ID: 1,
		  RequestString: `
		  {
			  "status":200,
			  "message":"ok, now you can use me"
		  }
		  `,
		  CreatedAt: time.Now(),
	  }
	  logRegister.FormatStringToJson()
	  if logRegister.RequestJson["status"] != nil {
		  fmt.Println(logRegister.RequestJson["status"])
	  }
	  if logRegister.RequestJson["message"] != nil {
		  fmt.Println(logRegister.RequestJson["message"])
	  }
  }
```

## 3. Obtener una Prueba de Cobertura de tu c√≥digo
Puedes verificar la prueba de cobertura de tu proyecto en una bonita interfaz en el navegador y verificar qu√© partes de tu c√≥digo necesitan ser probadas.

```shell
go test -coverprofile=coverage.out ./‚Ä¶ && go tool cover -html=coverage.out && rm coverage.out
```

<img width="100%" alt="golang-wallpaper " src="https://miro.medium.com/max/1400/1*NHVEWp5EHEAY__rn4US1Cg.png"/>

El c√≥digo que no ha sido comprobado aparecer√° en color rojo y el c√≥digo que ha sido comprobado en color verde.


## 4. Buscar si el String est√° dentro de un Slice
Otra situaci√≥n habitual son los problemas relacionados con la b√∫squeda simple de un string dentro de un slice. Por ejemplo, quiero hacer una lista sobre los campos que se pueden modificar en un endpoint. El m√©todo de b√∫squeda depender√° del tama√±o del array. En mi caso, son arrays muy cortos, entonces uso una b√∫squeda simple.

```go
  package main

  func StringInSlice(a string, list []string) bool {
	  for _, b := range list {
		  if b == a {
			  return true
		  }
	  }
	  return false
  }

  func main() {
	  permmitedFields := []string{"status", "message"}
	  field := "createdAt"

	  if StringInSlice(field, permmitedFields) {
		  println("the field is authorized")
	  }
	  println("the field is not authorized")
  }
```

## 5. Generar perfiles de CPU
Asimismo, una de mis herramientas favoritas es la generaci√≥n de perfiles de CPU para obtener un an√°lisis m√°s extenso del rendimiento de tu c√≥digo.
```shell
go test -cpuprofile=cpu.out ./‚Ä¶ && go tool pprof cpu.out && rm cpu.out
```

<img width="100%" alt="golang-wallpaper " src="https://miro.medium.com/max/1400/1*-JpIHiLuBs02DIORHu5dHA.png"/>